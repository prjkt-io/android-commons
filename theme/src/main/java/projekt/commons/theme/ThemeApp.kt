/*
 * Copyright (c) 2019, Projekt Development LLC.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package projekt.commons.theme

import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import projekt.commons.buildtools.BuildTools.getAapt
import projekt.commons.shell.Shell.exec
import projekt.commons.theme.backend.AndromedaBackend
import projekt.commons.theme.backend.AndromedaSamsungBackend
import projekt.commons.theme.backend.Backend
import projekt.commons.theme.backend.PieRootBackend
import projekt.commons.theme.backend.PieRootBackend.Companion.INSTALL_PREFIX
import projekt.commons.theme.backend.RootBackend
import projekt.commons.theme.backend.SynergyBackend
import projekt.commons.theme.backend.SubstratumServiceBackend
import projekt.commons.theme.internal.ThemeAppInitializeActivity
import projekt.commons.theme.internal.getCompatLongVersionCode
import projekt.commons.theme.internal.isPackageInstalled
import java.io.File

/**
 * Main class of this library.
 */
object ThemeApp {
    internal const val EXTRA_WITH_ANDROMEDA = "intent.extra.WITH_ANDROMEDA"
    internal const val EXTRA_WITH_SUBSTRATUM_SERVICE = "intent.extra.WITH_SUBSTRATUM_SERVICE"
    internal const val EXTRA_WITH_ROOT = "intent.extra.WITH_ROOT"
    internal const val EXTRA_WITH_PIE_ROOT = "intent.extra.WITH_PIE_ROOT"
    internal const val EXTRA_WITH_ANDROMEDA_SAMSUNG = "intent.extra.WITH_SUNGSTROMEDA"
    internal const val EXTRA_WITH_SYNERGY = "intent.extra.WITH_SYNERGY"
    internal const val EXTRA_RESULT_CODE = "intent.extra.RESULT_CODE"

    internal const val RESULT_PASS = -1
    internal const val RESULT_UNKNOWN = 0
    internal const val RESULT_NO_SUPPORTED_BACKEND = 1
    internal const val RESULT_ROOT_DENIED = 3
    internal const val RESULT_ROOT_NOT_SUPPORTED = 4
    internal const val RESULT_MAGISK_DISABLED = 5
    internal const val RESULT_ANDROMEDA_DENIED = 6
    internal const val RESULT_ANDROMEDA_INACTIVE = 7
    internal const val RESULT_SUBSTRATUM_SERVICE_DENIED = 8

    internal val isSamsung: Boolean
        get() {
            val listOfFeatures = ThemeApplication.instance.packageManager.systemSharedLibraryNames
            return listOfFeatures?.contains("touchwiz") ?: false ||
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
                    File("/system/etc/permissions/com.samsung.device.xml").exists()
        }

    internal val isSynergyInstalled: Boolean
        get() = "projekt.samsung.theme.compiler".isPackageInstalled()

    /**
     * Any overlays generated by this library will always have this "permission".
     */
    val OVERLAY_PERMISSION = "${ThemeApplication.instance.packageName}.OVERLAY_COMPONENT"

    /**
     * Any overlays generated by this library will always have this permission
     * if the host device runs Samsung OS.
     */
    const val SAMSUNG_OVERLAY_PERMISSION = "com.samsung.android.permission.SAMSUNG_OVERLAY_COMPONENT"

    /**
     * Returns `true` if the host OS runs modified version of OMS.
     * Usually custom ROMs.
     *
     * @see isSubstratumService
     */
    val isSubstratumOms: Boolean
        get() = ThemeApplication.instance.packageManager
                .hasSystemFeature("projekt.substratum.theme")

    /**
     * Returns `true` if the active [Backend] uses Andromeda Server.
     */
    val isAndromeda: Boolean
        get() = ThemeApplication.backend is AndromedaBackend

    /**
     * Returns `true` if the active [Backend] uses Substratum Service.
     *
     * @see isSubstratumOms
     */
    val isSubstratumService: Boolean
        get() = ThemeApplication.backend is SubstratumServiceBackend


    /**
     * Returns `true` if the active [Backend] uses root and if
     * [Build.VERSION.SDK_INT] >= [Build.VERSION_CODES.P].
     */
    val isPieRoot: Boolean
        get() = ThemeApplication.backend is PieRootBackend

    /**
     * Returns `true` if the active [Backend] uses root.
     */
    val isRoot: Boolean
        get() = ThemeApplication.backend is RootBackend

    /**
     * Returns `true` if the active [Backend] uses Andromeda Backend and
     * if [Build.VERSION.SDK_INT] < [Build.VERSION_CODES.P]
     */
    val isAndromedaSamsung: Boolean
        get() = ThemeApplication.backend is AndromedaSamsungBackend

    /**
     * Returns `true` if the active [Backend] uses Synergy
     */
    val isSynergy: Boolean
        get() = ThemeApplication.backend is SynergyBackend

    /**
     * This checks exists because custom fonts support is kind of
     * broken on P+
     *
     * @see isSubstratumService
     */
    val isSupportCustomFonts: Boolean
        get() = isSubstratumService && Build.VERSION.SDK_INT < Build.VERSION_CODES.P

    /**
     * Returns list of overlays in form of [OverlayPackageInfo]
     * in the magisk install location.
     *
     * Helpful to read overlay without the need of [PackageManager].
     */
    val magiskInstalledOverlay: List<OverlayPackageInfo>
        get() {
            val out = ArrayList<OverlayPackageInfo>()
            exec("ls ${PieRootBackend.PIE_INSTALL_DIR}").output.forEach { line ->
                getOverlayPackageInfo(line.substring(1, line.length - 4))?.let { out.add(it) }
            }
            return out
        }

    /**
     * Returns an activity [Intent] to initialize the [Backend] for
     * the theme app.
     *
     * @param context Context.
     * @param options Options of supported architecture and backend.
     */
    fun getInitIntent(context: Context, options: ThemeAppOptions): Intent {
        val bundle = Bundle()
        bundle.putBoolean(EXTRA_WITH_ANDROMEDA, options.withAndromeda)
        bundle.putBoolean(EXTRA_WITH_SUBSTRATUM_SERVICE, options.withSubstratumService)
        bundle.putBoolean(EXTRA_WITH_ROOT, options.withRoot)
        bundle.putBoolean(EXTRA_WITH_PIE_ROOT, options.withPieRoot)
        bundle.putBoolean(EXTRA_WITH_ANDROMEDA_SAMSUNG, options.withAndromedaSamsung)
        bundle.putBoolean(EXTRA_WITH_SYNERGY, options.withSynergy)
        return Intent(context, ThemeAppInitializeActivity::class.java).putExtras(bundle)
    }

    /**
     * Returns [InitResult] from init result intent.
     * @param intent result intent to be read.
     * @see getInitIntent
     */
    fun getResultFromIntent(intent: Intent): InitResult {
        return when (intent.getIntExtra(EXTRA_RESULT_CODE, RESULT_UNKNOWN)) {
            RESULT_PASS -> InitResult.Success
            RESULT_NO_SUPPORTED_BACKEND -> InitResult.NoSupportedBackendFailure
            RESULT_ROOT_DENIED -> InitResult.RootDeniedFailure
            RESULT_ROOT_NOT_SUPPORTED -> InitResult.RootNotSupportedFailure
            RESULT_MAGISK_DISABLED -> InitResult.MagiskDisabledFailure
            RESULT_ANDROMEDA_DENIED -> InitResult.AndromedaDeniedFailure
            RESULT_ANDROMEDA_INACTIVE -> InitResult.AndromedaInactiveFailure
            RESULT_SUBSTRATUM_SERVICE_DENIED -> InitResult.SubstratumServiceDeniedFailure
            else -> InitResult.UnknownFailure
        }
    }

    /**
     * Reads details of an installed overlay.
     *
     * @param overlayPackageName package name of overlay to be read.
     * @return Overlay details in form of [OverlayPackageInfo], `null` if
     * the overlay can't be read.
     */
    fun getOverlayPackageInfo(overlayPackageName: String): OverlayPackageInfo? {
        when {
            isPieRoot -> {
                // Always read directly from apk since we can't rely on the information
                // given by package manager because it's often outdated when user update
                // or reinstall the overlay
                if (exec(("if [ -f ${INSTALL_PREFIX}$overlayPackageName.apk ]; then echo '0'; fi"))
                                .output.isNotEmpty()) {
                    // Use AAPT to look inside the APK manually
                    val commandOutput = exec(("${getAapt(ThemeApplication.instance).absolutePath} d " +
                            "--include-meta-data badging $INSTALL_PREFIX$overlayPackageName.apk")).output
                    var versionCode = 0.toLong()
                    var versionName = ""
                    val metaData = Bundle()
                    commandOutput.forEach { line ->
                        when {
                            line.startsWith("package:") -> {
                                // Get version code
                                val code = line.substringAfter("versionCode='").substringBefore("'")
                                if (code.isNotEmpty()) {
                                    // TODO: This is wrong. See PackageInfo.getLongVersionCode()
                                    versionCode = code.toLong()
                                }
                                // Get version name
                                versionName = line.substringAfter("versionName='")
                                        .substringBefore("'")
                            }
                            line.startsWith("meta-data") -> {
                                val key = line.substringAfter("name='").substringBefore("'")
                                val value = line.substringAfter("value='").substringBefore("'")
                                metaData.putString(key, value)
                            }
                        }
                    }
                    return OverlayPackageInfo(overlayPackageName,
                            versionCode,
                            versionName,
                            metaData)
                }
            }
            else -> {
                try {
                    val pInfo = ThemeApplication.instance.packageManager
                            .getPackageInfo(overlayPackageName, PackageManager.GET_META_DATA)
                    return OverlayPackageInfo(overlayPackageName,
                            pInfo.getCompatLongVersionCode(),
                            pInfo.versionName,
                            pInfo.applicationInfo.metaData)
                } catch (ignored: PackageManager.NameNotFoundException) {
                }
            }
        }
        return null
    }

    /**
     * Get theme application backend with specified options. If the backend is
     * uninitialized, this method will try silently initialize it, assuming all
     * the requirements (permissions etc) for supported backend are fulfilled.
     * If not, then null will be returned.
     */
    fun getBackend(options: ThemeAppOptions): Backend? {
        if (ThemeApplication.backend == null) {
            runSilentInit(options)
        }
        return ThemeApplication.backend
    }

    /**
     * Checks whether the Samsung theme exposures is available to use.
     * @return `true` if host runs Samsung OS and is rooted.
     * @see canUseSamsungExposure
     * @see setSamsungExposureEnabled
     * @see isSamsungExposureEnabled
     */
    fun isSamsungExposureAvailable(): Boolean {
        return isSamsung && ThemeApplication.backend is PieRootBackend
    }

    /**
     * Checks whether the Samsung theme exposures can be used.
     * @return `true` if default system theme is applied or the exposures
     * is turned on by this library, `false` otherwise. Also returns
     * `false` if it's not available to use on the host OS
     * @see isSamsungExposureAvailable
     * @see setSamsungExposureEnabled
     * @see isSamsungExposureEnabled
     */
    fun canUseSamsungExposure(): Boolean {
        ThemeApplication.backend?.run {
            if (isSamsung && this is PieRootBackend) {
                return this.samsungExposureSwitchable
            }
        }
        return false
    }

    /**
     * Enables or disables the available Samsung exposures. If it can't be used
     * this method will fail silently.
     * @param enabled `true` to enable, `false` otherwise.
     * @see isSamsungExposureAvailable
     * @see canUseSamsungExposure
     * @see isSamsungExposureEnabled
     */
    fun setSamsungExposureEnabled(enabled: Boolean) {
        ThemeApplication.backend?.run {
            if (isSamsung && this is PieRootBackend) {
                this.samsungExposureEnabled = enabled
            }
        }
    }

    /**
     * Checks whether the Samsung exposures is enabled.
     * @return `true` if Samsung exposures is enabled, `false` otherwise. Also
     * returns `false` if it's not available to use on the host OS.
     * @see isSamsungExposureAvailable
     * @see canUseSamsungExposure
     * @see setSamsungExposureEnabled
     */
    fun isSamsungExposureEnabled(): Boolean {
        ThemeApplication.backend?.run {
            if (isSamsungExposureAvailable() && isSamsung && this is PieRootBackend) {
                return this.samsungExposureEnabled
            }
        }
        return false
    }

    /**
     * Silently reinitialize [Backend].
     */
    private fun runSilentInit(options: ThemeAppOptions): Boolean {
        if (ThemeApplication.backend == null) {
            return ThemeApplication.silentInitBackend(options.withAndromedaSamsung,
                    options.withAndromeda,
                    options.withSubstratumService,
                    options.withPieRoot,
                    options.withRoot)
        }
        return true
    }

    /**
     * This class represents the result of [Backend] initialization.
     *
     * @see getInitIntent
     * @see getResultFromIntent
     */
    sealed class InitResult {
        /**
         * Initialization is succeeded.
         */
        object Success : InitResult()

        /**
         * Initialization is failed because no supported [Backend] is
         * available on the device.
         */
        object NoSupportedBackendFailure : InitResult()

        /**
         * Initialization is failed because a root [Backend] is going
         * to be used but root access for the app is denied.
         */
        object RootDeniedFailure : InitResult()

        /**
         * Initialization is failed because a root [Backend] is going
         * to be used but the host root system is not supported.
         *
         * Any method of root is supported for device with
         * [Build.VERSION.SDK_INT] < [Build.VERSION_CODES.P], otherwise
         * only Magisk root is supported.
         */
        object RootNotSupportedFailure : InitResult()

        /**
         * Initialization is failed because the helper magisk module
         * is disabled.
         */
        object MagiskDisabledFailure : InitResult()

        /**
         * Initialization is failed because the active [Backend] is
         * going to use Andromeda Server but the app is not
         * permitted to access it.
         */
        object AndromedaDeniedFailure : InitResult()

        /**
         * Initialization is failed because the active [Backend] is
         * going to use Andromeda Server but the Server is inactive.
         */
        object AndromedaInactiveFailure : InitResult()

        /**
         * Initialization is failed because the active [Backend] is
         * going to use Substratum Service but the app is not
         * permitted to access it.
         */
        object SubstratumServiceDeniedFailure : InitResult()

        /**
         * We're not even sure why you able to go this deep.
         */
        object UnknownFailure : InitResult()
    }

    /**
     * Used to represent status of the installed overlay
     */
    object OverlayState {
        /**
         * Overlay is disabled.
         */
        val STATE_DISABLED = ThemeApplication.backend?.disabledStateValue

        /**
         * Overlay is enabled.
         */
        val STATE_ENABLED = ThemeApplication.backend?.enabledStateValue

        /**
         * Overlay is not active. Usually needs system reboot
         * to make it active.
         */
        const val STATE_NOT_ACTIVE = -1
    }
}
